// 贪心算法 + 二分查找

// start@1**************************************************
// 3 2 8 9 5 6 7 11 15 ->  求最长递增子序列的个数

// 2 8 9 11 15 (这一个不是最长递增子序列)
// 2 5 6 7 11 15 (这个最长递增子序列)

// 找更有潜力的
// 3
// 2 （2替换掉3）
// 2 8
// 2 8 9
// 2 5 9 （5替换掉8，二分查找，找到第一个比5大的进行替换）（仅大于当前值的：所有大于当前值的结果中的最小值）
// 2 5 6 （6替换掉9，二分查找，找到第一个比6大的进行替换）（仅大于当前值的：所有大于当前值的结果中的最小值）
// 2 5 6 7 11 15 (最长递增子序列)
// end@1**************************************************

// start@2**************************************************
// 3 2 8 9 5 6 7 11 15 4 ->  求最长递增子序列的个数

// 现在有个问题，如果序列最后加一个数字4，此算法求得结果为 2 4 6 7 11 15
// 虽然序列不对，但是序列长度是没问题的
// 2 5 6 7 11 15
// end@1**************************************************

// 1.思路就是当前这一项比我们最后一项大则直接放到末尾
// 2.如果当前这一项比最后一项小，需要在序列中通过二分查找找到比当前大的这一项，用他来替换掉
// 3.前驱节点追溯，替换掉错误的节点


// 实现思路1
function getSequence(arr) {
  const len = arr.length
  const result = [0] // 默认以数组中第0个为基准来做序列，注意！！存放的是数组 索引
  let resultLastIndex // 结果集中最后的索引

  for (let i = 0; i < len; i++) {
    let arrI = arr[i]
    // 因为在vue newIndexToOldIndexMap 中，0代表需要创建新元素，无需进行位置移动操作
    if (arrI !== 0) {
      resultLastIndex = result[result.length - 1]
      if (arrI > arr[resultLastIndex]) { // 比较当前项和最后一项的值，如果大于最后一项，则将当前索引添加到结果集中
        result.push(i) // 记录索引
      }
    }
  }
  return result
}

const newIndexToOldIndexMap = [10, 11, 12, 13, 14, 15, 16, 0]
console.log(getSequence(newIndexToOldIndexMap))
